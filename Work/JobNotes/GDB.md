1. 使用"sudo gdb JYNSAFED"

2. 打断点：在目的函数名 b CJYNetProtectionPluginImpl::onNewNotify

3. 执行：r

4. 逐过程：n       

5. 逐步骤：s      /会进入到函数内部

6. 完成当前函数：finish    /使用s进入到内部后，可以使用finish退出这个函数

7. p 变量名：打印变量名的值，确认是否正确收到并解析

8. bt：查看栈调用情况，如果程序崩溃可以通过栈查看那个地方有问题

9. quit ：退出

10. c/C：可以跳过当前断点要操作的内容，继续执行

11. 使用GDB调试：遇到某个函数执行，但是又不知道是那部分在调用这个函数时，使用`gdb`在这个函数打上断点，执行到这个函数时，执行`bt`查看栈，就可以看到调用函数一层一层的顺序了。

12. 当打印数据类型是原子类型时，比如`atmoc_bool`

    ```
    (gdb) p m_reportLog
    $11 = {_M_base = {static _S_alignment = 1, _M_i = true}}
    ```

    1. `_M_base` 和 `_M_i` 是 `std::atomic` 或其他标准库类型的内部表示。它们通常用于实现原子操作和存储状态。
    2. `_S_alignment` 是一个静态成员，表示这个类型在内存中的对齐要求。在这里，对齐为 `1` 字节，意味着该类型的对象在内存中必须以 1 字节对齐，这通常适用于 `bool` 类型。

13. gdb调试报错：

    1. 是否编译的依赖的so没有导过去
    2. **哪部分需要调试，就将哪部分执行文件单独拿出来使用gdb执行，其他部分正常启动执行**

    > 补充：后台使用systemctl start jyn*启动的是三个服务，CZ控制，ZDFY主动防御、safed安全三个。一个界面只展示两个，没有展示三个

14. 使用`systemctl`和`sudo`来启动某些服务的区别

    1. 有些可执行文件需要通过 **`systemctl`** 启动是因为它们作为 **服务（Service）** 或 **守护进程（Daemon）** 来运行，这种方式适用于在后台长期运行且需要稳定管理的程序
    2. **`sudo`**是用来以超级用户权限执行任意命令的工具，涉及到文件读取等


12. 在40上面编写的包在本地安装后。当使用gdb调试，打断点发现打的路径是40上面的路径。所以需要在本地打对应的包移动并替换，并且修改完JYNSAFED不仅需要把JYNSAFED转出，还需要把lib生成的动态库也转出。

13. gdb调试打断点，停在目标函数时，上方有传来的参数内存信息，可以查看是否传来的是否为空

14. gdb调试模式下程序崩溃，使用bt查看崩溃在那个函数。重新在该函数打断点，一步步复现，查看崩在那个位置。

15. 列出所有函数的地址和名称

    ```
    info functions		// 检查符号表是否正确加载 和 查找函数地址以设置断点
    ```

16. 调bug，哪个地方可能有问题，在那个地方打断点。使用gdb调试，单一看代码推断耗费时间。

17. gdb关于设置断点相关命令

      1. 设置断点

         ```
         break <函数名>    ->  b <函数名>
         break <文件名>:<行号>    ->  b <文件名>:<行号>
         
         break <函数名> if <条件>   ->  b <函数名> if <条件>
         break <文件名>:<行号> if <条件>  ->  b <文件名>:<行号> if <条件>
         ```

      2. 管理断点

         ```
         info breakpoints  ->  i b				// 列出所有断点
         info break <断点编号>   ->  i b <断点编号>	// 查看断点状态
         
         disable <断点编号>   ->  d <断点编号>	  // 禁用某断点
         enable <断点编号>    ->  e <断点编号>	  // 启用某断点
         delete <断点编号>    ->  del <断点编号>	  // 删除某断点
         ```

      3. 执行断点

         ```
         continue   ->  c	// 继续执行后续程序
         
         step       ->  s	// 逐步骤，进入函数内单步执行
         finish 	   ->  fin	// 在函数内执行剩余的代码直到函数返回，并且在返回时停止在调用该函数的地方
         
         next       ->  n	// 逐过程，跳过函数执行
         ```

18. 关于gdb给目标函数打断点

      1. 只b函数名，那么会匹配所有该函数名的函数(适用**全局函数**)

      2. 对于带有**命名空间**或者**类成员函数**，需要加上**命名空间/类名前缀**

      3. 不需要带返回值和参数。对于**重载函数**或**模板函数**，需要根据需要提供参数类型或模板参数以区分

         ```
         break my_function@int      	   # 匹配 my_function(int) 的重载版本
         break my_function@int,double   # 匹配 my_function(int,double) 的重载版本
         
         break my_template<int>    	   # 设置在模板函数 my_template<int> 的断点
         ```

19. 问题：当你通过 `include_directories` 添加了某些头文件路径，这些头文件对应的 `.cpp` 文件是否需要在 `add_library` 中显式地列出，或者是否可以仅通过头文件路径来引用这些源文件

    答：

    1. 如果 `.cpp` 文件是你自己定义的，并且它们需要被编译成库的一部分，你必须将这些 `.cpp` 文件列出在 `add_library` 中。如果你仅通过 `include_directories` 引用了其他目录的头文件，而没有将对应的 `.cpp` 文件包含到 `add_library` 中，编译器将找不到这些源文件并报错
    2. 如果你的代码依赖于外部库（比如系统库或第三方库），你可以通过 `target_link_libraries` 来指定这些库
    
20. gdb在启动带参数的可执行程序

    1. 启动时指定参数

       ```
       gdb --args ./your_program arg1 arg2 arg3
       ```

    2. 启动gdb后指定参数

       ```
       gdb ./your_program			// 启动gdb
       (gdb) run arg1 arg2 arg3	// 在gdb下，使用 run 命令（或简写为 r）并在后面加上参数：
       ```

    3. 通过`set args`命令设置参数：在启动 GDB 后**多次运行程序而无需重复输入参数**，可以使用 `set args` 命令。

       ```
       gdb ./your_program
       (gdb) set args arg1 arg2 arg3	// set args 是命令，后面的是实参
       ```

21. 